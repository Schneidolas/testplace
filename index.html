<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GigaPet AI - My Waifu</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
      :root {
          --black: #0f380f;
          --dark: #306230;
          --medium: #8bac0f;
          --light: #9bbc0f;
          --char-shadow: rgba(0,0,0,0.15);
          --ai-action-color: #7b2cbf;
      }
      *, *::before, *::after { box-sizing: border-box; }
      body {
          font-family: 'Press Start 2P', cursive;
          background: #222;
          display: flex;
          align-items: center;
          justify-content: center;
          min-height: 100vh;
          margin: 0;
          overflow: hidden;
          color: var(--light);
      }
      .hidden { display: none !important; }
      .app-wrapper {
          width: 800px;
          background: #2c3e50;
          border-radius: 10px;
          box-shadow: 0 10px 20px rgba(0,0,0,0.4);
          padding: 15px;
          display: flex;
          flex-direction: column;
      }
      .app-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 10px 20px;
          background: var(--black);
          border-radius: 5px;
          margin-bottom: 15px;
          font-size: 14px;
          flex-wrap: wrap;
      }
      .header-info { display: flex; flex-direction: column; gap: 4px; }
      .personality-display { color: var(--medium); font-size: 12px; }
      .game-container {
          background: var(--black);
          border: 4px solid var(--dark);
          border-radius: 5px;
          padding: 8px;
          position: relative;
          display: flex;
          flex-direction: column;
      }
      .screen {
          background-color: var(--light);
          width: 100%;
          height: 450px;
          position: relative;
          overflow: hidden;
          display: flex;
          flex-direction: column;
          justify-content: flex-end;
          background-repeat: no-repeat;
          background-size: cover;
          background-position: center bottom;
          transition: background-color 2s linear;
          border: 2px solid var(--dark);
      }
      .controls {
          background: var(--dark);
          padding-top: 8px;
          margin: 8px -8px -8px -8px;
          border-radius: 0 0 5px 5px;
          border-top: 2px solid var(--black);
      }
      .stats-container { display: flex; justify-content: space-around; padding: 0 8px; }
      .status-bar-container { width: 30%; }
      .status-label { font-size: 12px; color: var(--light); margin: 0 0 4px; text-align: center; }
      .progress-bar-outline { background: var(--black); padding: 2px; height: 12px; border-radius: 4px; }
      .progress-bar-fill { background: var(--medium); height: 100%; border-radius: 2px; transition: width 0.5s ease; }
      .actions-container { display: flex; flex-wrap: wrap; justify-content: center; padding: 10px; gap: 10px; min-height: 80px; }
      .action-btn {
          font-family: inherit;
          font-size: 14px;
          background: var(--medium);
          color: var(--black);
          border: none;
          border-radius: 5px;
          padding: 12px;
          cursor: pointer;
          flex-grow: 1;
          text-align: center;
          min-width: 150px;
          border-bottom: 3px solid var(--dark);
      }
      .action-btn:disabled { background: #5a7409; color: #306230; cursor: not-allowed; }
      .action-btn:active:not(:disabled) { transform: translateY(2px); border-bottom-width: 1px; }
      .file-upload-label { display: inline-block; text-align: center; cursor: pointer; }
      .affection-status { font-size: 14px; text-align: center; padding: 8px 0; }
      .affection-tier-name { color: var(--medium); font-weight: bold; }
      .character {
          position: absolute;
          bottom: 30px;
          left: 50%;
          transform: translateX(0px);
          transform-origin: center bottom;
          z-index: 5;
          width: 96px;
          margin-left: -48px;
      }
      @keyframes walking-bob { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
      .character.walking .character-bob { animation: walking-bob 0.5s ease-in-out infinite; }
      .character-bob { position: relative; transform-origin: center bottom; }
      .character-shadow {
          width: 80px; height: 15px; background: var(--char-shadow);
          border-radius: 50%; position: absolute; bottom: -5px;
          left: 50%; transform: translateX(-50%);
      }
      .character-sprite { width: 100%; height: 160px; position: relative; }
      .character-image { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
      .speech-bubble {
          position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%);
          background: white; color: black; padding: 12px 18px; border-radius: 10px;
          font-size: 14px; z-index: 20; max-width: 90%; text-align: center;
          border: 3px solid var(--black); box-shadow: 0 4px 8px rgba(0,0,0,0.2);
          opacity: 0; visibility: hidden; transition: all 0.2s;
      }
      .speech-bubble.visible { opacity: 1; visibility: visible; }
      .speech-bubble::after {
          content: ''; position: absolute; bottom: -12px; left: 50%;
          transform: translateX(-50%); border-width: 13px 13px 0; border-style: solid;
          border-color: white transparent; display: block; width: 0;
          filter: drop-shadow(0 2px 1px rgba(0,0,0,0.1));
      }
      .interaction-popup {
          position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
          background: rgba(15, 56, 15, 0.9); padding: 10px 15px; border-radius: 5px;
          font-size: 14px; z-index: 25; text-align: center;
          animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
      }
      @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, 10px); } to { opacity: 1; transform: translate(-50%, 0); } }
      @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
      .cutscene-overlay {
          position: absolute; top: 0; left: 0; width: 100%; height: 100%;
          background: rgba(0,0,0,0.8); z-index: 30; animation: fadeIn 2s;
      }
      .game-over-overlay {
          position: absolute; top: 0; left: 0; width: 100%; height: 100%;
          background: rgba(0,0,0,0.8); z-index: 50; display: flex; align-items: center; justify-content: center;
      }
      .game-over-box {
          background: var(--light); color: var(--black); padding: 25px; border-radius: 5px;
          text-align: center; border: 3px solid var(--black);
      }
      .game-over-box h2 { font-size: 24px; margin: 0 0 10px; }
      .game-over-box p { font-size: 14px; margin: 0 0 20px; max-width: 300px; }
      .anim-hunger .character-bob { animation: convulse 0.2s infinite; }
      @keyframes convulse {
          0%, 100% { transform: translate(0, 0) rotate(0); }
          25% { transform: translate(-2px, 0) rotate(-3deg); }
          75% { transform: translate(2px, 0) rotate(3deg); }
      }
      .anim-sadness .character-bob { animation: hang-sway 4s ease-in-out infinite; }
      .rope {
          position: absolute; top: -40px; left: 50%; width: 2px;
          height: 40px; background: #8B4513; transform: translateX(-50%);
      }
      @keyframes hang-sway { 0%, 100% { transform: rotate(5deg); } 50% { transform: rotate(-5deg); } }
      .anim-psycho .character-bob { animation: psycho-twitch 0.5s infinite; }
      .knife { width: 10px; height: 30px; background: #ccc; position: absolute; z-index: 10; top: 80px; right: 10px; transform: rotate(20deg); border: 1px solid #333; border-radius: 4px 0 0 4px; }
      @keyframes psycho-twitch { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(2px); } }
      .action-info-text { text-align: center; width: 100%; font-size: 14px; padding: 15px 0; }
      .wide-btn { flex-basis: 100% !important; flex-grow: 1 !important; }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="app-wrapper" class="app-wrapper">
        <header id="app-header" class="app-header">
            <div class="header-info">
              <div id="location-display" class="location-display"></div>
              <div id="personality-display" class="personality-display"></div>
            </div>
            <div id="time-display" class="time-display"></div>
        </header>
        <div class="game-container">
            <div id="cutscene-overlay" class="cutscene-overlay hidden"></div>
            <div id="game-over-overlay" class="game-over-overlay hidden">
                <div class="game-over-box">
                    <h2 id="game-over-title">Fim de Jogo</h2>
                    <p id="game-over-message"></p>
                    <button id="restart-btn" class="action-btn">Reiniciar</button>
                </div>
            </div>
            <div id="screen" class="screen">
                <div id="interaction-popup" class="interaction-popup hidden"></div>
                <div id="speech-bubble" class="speech-bubble"></div>
                <div id="character" class="character">
                    <div id="character-bob" class="character-bob">
                        <div class="character-shadow"></div>
                        <div class="character-sprite">
                            <div id="rope" class="rope hidden"></div>
                            <div id="knife" class="knife hidden"></div>
                            <img id="character-image" src="./character.png" alt="Character" class="character-image" />
                        </div>
                    </div>
                </div>
            </div>
            <div class="controls">
                <div class="stats-container">
                    <div class="status-bar-container">
                        <p class="status-label">Humor</p>
                        <div class="progress-bar-outline">
                            <div id="mood-bar" class="progress-bar-fill"></div>
                        </div>
                    </div>
                    <div class="status-bar-container">
                        <p class="status-label">Fome</p>
                        <div class="progress-bar-outline">
                            <div id="hunger-bar" class="progress-bar-fill"></div>
                        </div>
                    </div>
                    <div class="status-bar-container">
                        <p class="status-label">Higiene</p>
                        <div class="progress-bar-outline">
                            <div id="hygiene-bar" class="progress-bar-fill"></div>
                        </div>
                    </div>
                </div>
                <div id="affection-status" class="affection-status"></div>
                <div id="actions-container" class="actions-container"></div>
            </div>
        </div>
    </div>
<script>
document.addEventListener('DOMContentLoaded', () => {

// --- CONSTANTS, TYPES & DATA ---
const SAVE_KEY = 'gemochi_save_v2';
const STAT_MAX = 100;
const DEATH_TIMER_DURATION = 30000;
const TIME_SPEED_MULTIPLIER = 20;
const DECAY_TICK_INTERVAL = 30000; // 30 seconds for stat decay

const FEMALE_NAMES = ["Lia", "Pixel", "Nina", "Gabi", "Tete", "Carol", "Emi", "Flora", "Maya", "Yuki"];
const PERSONALITIES = ['TIMIDA', 'CALADA', 'IMPULSIVA', 'BOCA_SUJA', 'FOFA', 'MALANDRA', 'PIADISTA', 'SAFADA', 'BAGUNCEIRA', 'NORMAL', 'MENTE_FECHADA'];
const PERSONALITY_NAMES = {
    TIMIDA: "Tímida", CALADA: "Calada", IMPULSIVA: "Impulsiva", BOCA_SUJA: "Boca Suja",
    FOFA: "Fofa", MALANDRA: "Malandra", PIADISTA: "Piadista", SAFADA: "Safada",
    BAGUNCEIRA: "Bagunceira", NORMAL: "Normal", MENTE_FECHADA: "Mente Fechada"
};

const AFFECTION_TIERS = {
    PSYCHOPATH:   { min: -Infinity, max: -81, name: 'Psicopata' },
    HATE:         { min: -80, max: -41, name: 'Ódio' },
    ENMITY:       { min: -40, max: -11, name: 'Inimizade' },
    UNKNOWN:      { min: -10, max: 10,  name: 'Desconhecida' },
    ACQUAINTANCE: { min: 11,  max: 30,  name: 'Conhecida' },
    FRIEND:       { min: 31,  max: 60,  name: 'Amiga' },
    BEST_FRIEND:  { min: 61,  max: 90,  name: 'Melhor Amiga' },
    GIRLFRIEND:   { min: 91,  max: 150, name: 'Namorada' },
    WIFE:         { min: 151, max: Infinity, name: 'Esposa' },
};

const LOCATION_NAMES = {
    QUARTO: 'Quarto', SALA_DE_ESTAR: 'Sala de Estar', COZINHA: 'Cozinha', BANHEIRO: 'Banheiro',
    QUINTAL: 'Quintal', SORVETERIA: 'Sorveteria', SHOPPING: 'Shopping', BOLICHE: 'Boliche',
};

const LOCATION_BACKGROUNDS = {
    SALA_DE_ESTAR: 'https://i.imgur.com/v83F41j.png', // Living Room
    QUARTO: 'https://i.imgur.com/eBwSj3d.png',      // Bedroom
    COZINHA: 'https://i.imgur.com/iC5e3sv.png',       // Kitchen
    BANHEIRO: 'https://i.imgur.com/jPBsHgr.png',     // Bathroom
    QUINTAL: 'https://i.imgur.com/2s3D3sA.png',       // Backyard
    SORVETERIA: 'https://i.imgur.com/eBwZ8r2.png',
    SHOPPING: 'https://i.imgur.com/bT6nB6j.png',
    BOLICHE: 'https://i.imgur.com/sSgWnFf.png',
};

const PROPOSAL_DIALOGUE = {
    petText: "Eu... preciso te dizer algo. Sinto que o que temos é mais que amizade. Você... quer namorar comigo?",
    isProposal: true, positiveResponse: { text: "Sim! Eu quero!", moodEffect: 50 }, negativeResponse: { text: "Desculpe, não sinto o mesmo.", moodEffect: -50 },
};

const MARRIAGE_PROPOSAL_DIALOGUE = {
    petText: "Meu amor... eu não consigo mais imaginar um futuro que não seja com você nele. Você... aceita se casar comigo?",
    isProposal: true, isMarriage: true, positiveResponse: { text: "Sim, mil vezes sim!" }, negativeResponse: { text: "Eu... não posso." }
};


// --- DIALOGUE DATABASE GENERATION ---
const DIALOGUE_MATRIX = {
    NORMAL: {
        UNKNOWN: { pet: ["O dia está meio {adj}.", "Pensando no que fazer hoje...", "Às vezes o silêncio é bom, né?"], pos: ["Concordo.", "Tenho umas ideias.", "Sim, é relaxante."], neg: ["Achei normal.", "Sei lá.", "Detesto silêncio."], fragments: { adj: ['parado', 'estranho', 'calmo'] } },
        FRIEND: { pet: ["Se a gente tivesse um super poder, qual seria o mais inútil?", "Qual a sua opinião sobre {topic}?", "Lembra daquela vez que a gente {memory}?"], pos: ["Controlar a cor do céu.", "Acho uma loucura.", "Como esquecer!"], neg: ["Não sei.", "Tanto faz.", "Não lembro disso."], fragments: { topic: ['abacaxi na pizza', 'gatos dominando o mundo'], memory: ['tentou cozinhar e queimou tudo', 'riu até a barriga doer'] } },
        GIRLFRIEND: { pet: ["Pensei na gente hoje.", "Saudades de você, mesmo estando aqui do lado.", "Você me faz tão bem."], pos: ["Eu também pensei em nós.", "Own, que fofo.", "Você também me faz bem."], neg: ["Que legal.", "Que exagero.", "Ok."] }
    },
    FOFA: {
        UNKNOWN: { pet: ["O-oi... {emote}", "O dia está bonito hoje, né?", "Espero... não estar incomodando..."], pos: ["Oi! Tudo bem?", "Sim, está lindo.", "Você nunca incomoda."], neg: ["Oi.", "Tanto faz.", "Está sim."], fragments: { emote: ['(⁄ ⁄>⁄ ▽ ⁄<⁄ ⁄)', '(´｡• ᵕ •｡`)', '(*^.^*)'] } },
        FRIEND: { pet: ["Vamos ver um filme bem bobinho e comer pipoca até a barriga doer?", "E se a gente fizesse uma cabana de cobertores aqui na sala?", "Me conta um segredo seu? Eu conto um meu! {emote}"], pos: ["Amei a ideia!", "SÓ VAMOS!", "Claro, pode começar."], neg: ["Prefiro outra coisa.", "Que bagunça...", "Melhor não."], fragments: { emote: ['(o´▽`o)', '(^w^)', '(*≧▽≦)'] } },
    },
    BOCA_SUJA: {
        UNKNOWN: { pet: ["E aí, porra. Tá olhando o quê?", "Que saco, nada pra fazer nessa merda.", "Fala logo o que tu quer."], pos: ["Admirando a paisagem.", "A gente inventa algo.", "Calma, porra."], neg: ["Perdi meu tempo.", "A culpa é sua.", "Não te devo satisfação."] },
        HATE: { pet: ["Some da minha frente, caralho.", "Não enche meu saco, vai se foder.", "Encosta em mim de novo e eu quebro sua cara."], pos: ["Ok, tô indo.", "Foi mal.", "Credo, pra que isso?"], neg: ["Me obrigue.", "O problema é seu.", "Tenta a sorte, otário."]},
    }
};

let dialogueDatabase = {};

function getRandom(arr) {
    if (!arr || arr.length === 0) return '';
    return arr[Math.floor(Math.random() * arr.length)];
}

function createDialogueSet(count, petTemplates, posTemplates, negTemplates, fragments = {}) {
    const dialogues = [];
    if (!petTemplates || petTemplates.length === 0) return [{ petText: '...', positiveResponse: { text: 'Ok.' }, negativeResponse: { text: '...' } }];
    
    for (let i = 0; i < count; i++) {
        let petText = getRandom(petTemplates);
        for (const key in fragments) {
            if (petText.includes(`{${key}}`)) {
                petText = petText.replace(new RegExp(`{${key}}`, 'g'), getRandom(fragments[key]));
            }
        }
        dialogues.push({
            petText: petText,
            positiveResponse: { text: getRandom(posTemplates), moodEffect: 10, affectionEffect: 2 },
            negativeResponse: { text: getRandom(negTemplates), moodEffect: -10, affectionEffect: -2 },
        });
    }
    return dialogues;
}

function buildFullDatabase() {
    const finalDb = {};
    const tiers = Object.keys(AFFECTION_TIERS);

    for (const p of PERSONALITIES) {
        finalDb[p] = {};
        for (const t of tiers) {
            const personalityMatrix = DIALOGUE_MATRIX[p] || DIALOGUE_MATRIX.NORMAL;
            const affectionMatrix = personalityMatrix[t] || personalityMatrix.UNKNOWN || DIALOGUE_MATRIX.NORMAL.UNKNOWN;
            
            finalDb[p][t] = createDialogueSet(50, affectionMatrix.pet, affectionMatrix.pos, affectionMatrix.neg, affectionMatrix.fragments);
        }
    }
    return finalDb;
}


// --- DOM ELEMENTS ---
const dom = {
    appWrapper: document.getElementById('app-wrapper'),
    header: {
        location: document.getElementById('location-display'),
        personality: document.getElementById('personality-display'),
        time: document.getElementById('time-display'),
    },
    screen: document.getElementById('screen'),
    overlays: {
        cutscene: document.getElementById('cutscene-overlay'),
        gameOver: document.getElementById('game-over-overlay'),
        gameOverMsg: document.getElementById('game-over-message'),
        restartBtn: document.getElementById('restart-btn'),
    },
    character: {
        container: document.getElementById('character'),
        bob: document.getElementById('character-bob'),
        image: document.getElementById('character-image'),
        rope: document.getElementById('rope'),
        knife: document.getElementById('knife'),
    },
    ui: {
        speechBubble: document.getElementById('speech-bubble'),
        interactionPopup: document.getElementById('interaction-popup'),
        moodBar: document.getElementById('mood-bar'),
        hungerBar: document.getElementById('hunger-bar'),
        hygieneBar: document.getElementById('hygiene-bar'),
        affectionStatus: document.getElementById('affection-status'),
        actionsContainer: document.getElementById('actions-container'),
    }
};


// --- GAME STATE & LOGIC ---
let gameState = {};
let gameIntervals = { clock: null, decay: null, movement: null, death: null, save: null };
let interactionTimeout = null;

function saveState() { try { localStorage.setItem(SAVE_KEY, JSON.stringify(gameState)); } catch (e) { console.warn("Failed to save state.", e); } }
function loadState() { try { const saved = localStorage.getItem(SAVE_KEY); return saved ? JSON.parse(saved) : null; } catch (e) { console.warn("Failed to load state.", e); return null; } }

function createNewGame() {
    const personality = getRandom(PERSONALITIES);
    return {
        name: getRandom(FEMALE_NAMES),
        personality: personality,
        personalityName: PERSONALITY_NAMES[personality],
        characterImageUrl: './character.png',
        mood: 80, hunger: 80, hygiene: 80,
        affection: 0,
        isAlive: true,
        deathType: null,
        gameTime: { year: 1, month: 1, day: 1, hour: 8, minute: 0 },
        zeroHungerTime: null,
        zeroMoodTime: null,
        currentLocation: 'QUARTO',
        view: 'HOME',
        isTalking: false,
        isWalking: false,
        facingDirection: 'right',
        transitionDuration: '0s',
        charPositionX: 0,
        currentDialogue: null,
    };
}

function getAffectionTier(affection) {
    for (const key in AFFECTION_TIERS) {
        if (affection >= AFFECTION_TIERS[key].min && affection <= AFFECTION_TIERS[key].max) return key;
    }
    return 'UNKNOWN';
}

function showInteractionMessage(text, duration = 2000) {
    dom.ui.interactionPopup.textContent = text;
    dom.ui.interactionPopup.classList.remove('hidden');
    if (interactionTimeout) clearTimeout(interactionTimeout);
    interactionTimeout = setTimeout(() => dom.ui.interactionPopup.classList.add('hidden'), duration);
}

// --- RENDER ---
function render() {
    if (!gameState || Object.keys(gameState).length === 0) return;

    // Time & Location
    const time = gameState.gameTime;
    dom.header.time.textContent = `D${time.day}/${time.month} - ${String(time.hour).padStart(2, '0')}:${String(time.minute).padStart(2, '0')}`;
    dom.header.location.textContent = `${gameState.name} em ${LOCATION_NAMES[gameState.currentLocation]}`;
    dom.header.personality.textContent = `Personalidade: ${gameState.personalityName}`;

    // Screen background & sky color
    dom.screen.style.backgroundImage = `url(${LOCATION_BACKGROUNDS[gameState.currentLocation]})`;
    const hour = gameState.gameTime.hour;
    let skyColor = 'rgba(0,0,0,0)';
    if (hour < 7) skyColor = 'rgba(15, 56, 15, 0.5)';
    else if (hour < 8) skyColor = 'rgba(255, 147, 41, 0.2)';
    else if (hour < 18) skyColor = 'rgba(0,0,0,0)';
    else if (hour < 20) skyColor = 'rgba(255, 147, 41, 0.3)';
    else if (hour < 22) skyColor = 'rgba(23, 76, 133, 0.4)';
    else skyColor = 'rgba(15, 56, 15, 0.5)';
    dom.screen.style.backgroundColor = skyColor;
    
    // Character
    dom.character.image.src = gameState.characterImageUrl;
    dom.character.container.style.transition = `transform ${gameState.transitionDuration} linear`;
    dom.character.container.style.transform = `translateX(${gameState.charPositionX}px) scaleX(${gameState.facingDirection === 'right' ? 1 : -1})`;
    dom.character.container.classList.toggle('walking', gameState.isWalking);
    
    // Stats
    dom.ui.moodBar.style.width = `${gameState.mood}%`;
    dom.ui.hungerBar.style.width = `${gameState.hunger}%`;
    dom.ui.hygieneBar.style.width = `${gameState.hygiene}%`;
    const affectionTierName = AFFECTION_TIERS[getAffectionTier(gameState.affection)].name;
    dom.ui.affectionStatus.innerHTML = `Afeto: <span class="affection-tier-name">${affectionTierName}</span>`;

    // Dialogue
    dom.ui.speechBubble.classList.toggle('visible', gameState.isTalking);
    if(gameState.isTalking) dom.ui.speechBubble.textContent = gameState.currentDialogue.petText;

    // Actions
    renderActions();

    // Death state
    dom.character.bob.className = 'character-bob'; // reset animation class
    if (gameState.deathType) {
        dom.overlays.cutscene.classList.remove('hidden');
        dom.character.bob.classList.add(`anim-${gameState.deathType}`);
        dom.character.rope.classList.toggle('hidden', gameState.deathType !== 'sadness');
        dom.character.knife.classList.toggle('hidden', gameState.deathType !== 'psycho');
    } else {
        dom.overlays.cutscene.classList.add('hidden');
        dom.character.rope.classList.add('hidden');
        dom.character.knife.classList.add('hidden');
    }
}

function renderActions() {
    const container = dom.ui.actionsContainer;
    container.innerHTML = ''; // Clear previous buttons

    if (!gameState.isAlive) {
        container.innerHTML = `<p class="action-info-text">...</p>`;
        return;
    }
    
    if (gameState.isTalking) {
        const d = gameState.currentDialogue;
        container.innerHTML = `
            <button class="action-btn" data-action="dialogue" data-type="positive">${d.positiveResponse.text}</button>
            <button class="action-btn" data-action="dialogue" data-type="negative">${d.negativeResponse.text}</button>
            ${d.isProposal ? '' : '<button class="action-btn wide-btn" data-action="dialogue" data-type="leave">[Sair]</button>'}
        `;
        return;
    }
    
    const affectionTier = getAffectionTier(gameState.affection);
    const isDatingOrMarried = affectionTier === 'GIRLFRIEND' || affectionTier === 'WIFE';

    let buttons = [];
    if (isDatingOrMarried) {
        switch(gameState.view) {
            case 'HOME':
                buttons.push({ text: 'Cômodos', action: 'setView', value: 'MENU_COMODOS' });
                buttons.push({ text: 'Interagir', action: 'setView', value: 'MENU_INTERACOES' });
                buttons.push({ text: 'Conversar', action: 'talk' });
                break;
            case 'MENU_COMODOS':
                buttons.push({ text: 'Quarto', action: 'setLocation', value: 'QUARTO' });
                buttons.push({ text: 'Sala', action: 'setLocation', value: 'SALA_DE_ESTAR' });
                buttons.push({ text: 'Cozinha', action: 'setLocation', value: 'COZINHA' });
                if (affectionTier === 'WIFE') buttons.push({ text: 'Quintal', action: 'setLocation', value: 'QUINTAL' });
                buttons.push({ text: 'Voltar', action: 'setView', value: 'HOME', wide: true });
                break;
            case 'MENU_INTERACOES':
                 switch(gameState.currentLocation) {
                    case 'QUARTO': buttons.push({ text: 'Oba-oba', action: 'interact', value: 'oba' }); break;
                    case 'COZINHA': buttons.push({ text: 'Alimentar', action: 'feed' }); break;
                    case 'SALA_DE_ESTAR': buttons.push({ text: 'Assistir Filme', action: 'interact', value: 'movie' }); break;
                    case 'QUINTAL': buttons.push({ text: 'Viagem', action: 'setView', value: 'MENU_VIAGEM' }); break;
                 }
                buttons.push({ text: 'Armário', action: 'setView', value: 'MENU_ARMARIO' });
                buttons.push({ text: 'Voltar para Casa', action: 'goHome', wide: true });
                break;
            case 'MENU_VIAGEM':
                buttons.push({ text: 'Sorveteria', action: 'setLocation', value: 'SORVETERIA' });
                buttons.push({ text: 'Shopping', action: 'setLocation', value: 'SHOPPING' });
                buttons.push({ text: 'Boliche', action: 'setLocation', value: 'BOLICHE' });
                buttons.push({ text: 'Voltar', action: 'setView', value: 'MENU_INTERACOES', wide: true });
                break;
            case 'MENU_ARMARIO':
                container.innerHTML = `<label class="action-btn file-upload-label"> Importar Imagem <input type="file" id="image-upload" accept="image/*" style="display: none;" /> </label>`;
                container.innerHTML += `<button class="action-btn wide-btn" data-action="setView" data-value="MENU_INTERACOES">Voltar</button>`;
                return;
        }
    } else {
        buttons.push({ text: 'Alimentar', action: 'feed' });
        buttons.push({ text: 'Limpar', action: 'wash' });
        const canTalk = affectionTier !== 'HATE' && affectionTier !== 'PSYCHOPATH';
        buttons.push({ text: 'Conversar', action: 'talk', disabled: !canTalk });
    }

    container.innerHTML = buttons.map(b => `<button class="action-btn ${b.wide ? 'wide-btn': ''}" data-action="${b.action}" data-value="${b.value || ''}" ${b.disabled ? 'disabled' : ''}>${b.text}</button>`).join('');
}


// --- GAME LOOPS & ACTIONS ---
function handleActionClick(e) {
    const target = e.target.closest('button[data-action]');
    if (!target || !gameState.isAlive) return;

    const { action, value, type } = target.dataset;

    switch (action) {
        case 'feed':
            gameState.hunger = Math.min(STAT_MAX, gameState.hunger + 25);
            gameState.mood = Math.min(STAT_MAX, gameState.mood + 5);
            showInteractionMessage(`${gameState.name} comeu e parece satisfeita.`);
            break;
        case 'wash':
            gameState.hygiene = STAT_MAX;
            showInteractionMessage(`Você limpou ${gameState.name}.`);
            break;
        case 'talk':
            handleTalk();
            break;
        case 'dialogue':
            handleDialogueChoice(type);
            break;
        case 'setView':
            gameState.view = value;
            break;
        case 'setLocation':
            gameState.currentLocation = value;
            gameState.view = 'HOME';
            break;
        case 'goHome':
            gameState.currentLocation = 'QUARTO';
            gameState.view = 'HOME';
            break;
        case 'interact':
            if (value === 'oba') showInteractionMessage('As luzes diminuem... :)', 3000);
            if (value === 'movie') showInteractionMessage('Vocês assistem a um filme romântico.', 3000);
            gameState.mood = Math.min(STAT_MAX, gameState.mood + 15);
            break;
    }
    render();
}

function handleTalk() {
    if (gameState.isTalking) return;
    const affectionTier = getAffectionTier(gameState.affection);
    const dialogues = dialogueDatabase[gameState.personality]?.[affectionTier] || dialogueDatabase.NORMAL.UNKNOWN;
    const dialogue = getRandom(dialogues);
    
    // Check for proposals
    const oldAffection = gameState.affection;
    if(oldAffection >= 90 && oldAffection <= 95 && affectionTier === 'BEST_FRIEND') {
        gameState.currentDialogue = PROPOSAL_DIALOGUE;
    } else if (oldAffection >= 150 && oldAffection <= 155 && affectionTier === 'GIRLFRIEND') {
        gameState.currentDialogue = MARRIAGE_PROPOSAL_DIALOGUE;
    } else {
        gameState.currentDialogue = dialogue;
    }
    
    gameState.isTalking = true;
    render();
}

function handleDialogueChoice(type) {
    const d = gameState.currentDialogue;
    if (type !== 'leave') {
        if (d.isProposal) {
            if (type === 'positive') {
                gameState.affection = d.isMarriage ? 151 : 91;
                showInteractionMessage(d.isMarriage ? "É o dia mais feliz da vida de vocês!" : "Vocês estão namorando!", 4000);
            } else {
                gameState.affection = d.isMarriage ? 40 : -20;
                showInteractionMessage(d.isMarriage ? "O coração dela se partiu..." : "Ela ficou de coração partido.", 4000);
            }
        } else {
            const response = d[type === 'positive' ? 'positiveResponse' : 'negativeResponse'];
            gameState.mood = Math.max(0, Math.min(STAT_MAX, gameState.mood + response.moodEffect));
            gameState.affection += response.affectionEffect;
        }
    }
    gameState.isTalking = false;
    gameState.currentDialogue = null;
    render();
}

function handleImageUpload(e) {
    const file = e.target.files?.[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            gameState.characterImageUrl = event.target.result;
            showInteractionMessage("Visual atualizado!", 2000);
            render();
        };
        reader.readAsDataURL(file);
    }
}

function clockTick() {
    if (!gameState.isAlive) return;
    let { year, month, day, hour, minute } = gameState.gameTime;
    minute += TIME_SPEED_MULTIPLIER;
    if (minute >= 60) { hour += Math.floor(minute / 60); minute %= 60; }
    if (hour >= 24) { day += Math.floor(hour / 24); hour %= 24; }
    if (day > 30) { month += Math.floor(day / 30); day %= 30; if(day === 0) day = 1; }
    if (month > 12) { year += Math.floor(month / 12); month %= 12; if(month === 0) month = 1; }
    gameState.gameTime = { year, month, day, hour, minute };
    render();
}

function decayTick() {
    if (!gameState.isAlive || gameState.isTalking) return;
    gameState.hunger = Math.max(0, gameState.hunger - 1);
    gameState.hygiene = Math.max(0, gameState.hygiene - 1);
    const isDirty = gameState.hygiene < 30;
    gameState.mood = Math.max(0, gameState.mood - (isDirty ? 1.5 : 1));
    render();
}

function deathCheck() {
    if (!gameState.isAlive) return;
    
    // Hunger death
    if (gameState.hunger <= 0) {
        if (gameState.zeroHungerTime === null) gameState.zeroHungerTime = Date.now();
        if (Date.now() - gameState.zeroHungerTime > DEATH_TIMER_DURATION) { triggerDeath('hunger'); return; }
    } else {
        gameState.zeroHungerTime = null;
    }

    // Sadness death
    if (gameState.mood <= 0) {
        if (gameState.zeroMoodTime === null) gameState.zeroMoodTime = Date.now();
        if (Date.now() - gameState.zeroMoodTime > DEATH_TIMER_DURATION) { triggerDeath('sadness'); return; }
    } else {
        gameState.zeroMoodTime = null;
    }

    // Psycho death
    if (getAffectionTier(gameState.affection) === 'PSYCHOPATH') {
        triggerDeath('psycho');
    }
}

function triggerDeath(reason) {
    if (!gameState.isAlive) return;
    
    stopGame();
    gameState.isAlive = false;
    gameState.deathType = reason;
    let msg = '';
    switch (reason) {
        case 'hunger': msg = `${gameState.name} desmaiou de fraqueza e não acordou mais.`; break;
        case 'sadness': msg = `A tristeza foi demais para ${gameState.name}. Ela se foi.`; break;
        case 'psycho': msg = `Ela te olhou com um vazio aterrorizante... Você apagou.`; break;
    }
    
    render(); // Render the death animation
    
    setTimeout(() => {
        dom.overlays.gameOver.classList.remove('hidden');
        dom.overlays.gameOverMsg.textContent = msg;
    }, 2500);
}

function movementTick() {
    clearTimeout(gameIntervals.movement); // Clear previous timeout
    if (gameState.isTalking || !gameState.isAlive || gameState.deathType) {
        gameState.isWalking = false;
        render();
        gameIntervals.movement = setTimeout(movementTick, Math.random() * 3000 + 2000);
        return;
    }
    const isCurrentlyWalking = Math.random() > 0.4;
    if (isCurrentlyWalking) {
        const newTargetX = (Math.random() - 0.5) * 350;
        gameState.facingDirection = newTargetX > gameState.charPositionX ? 'right' : 'left';
        const distance = Math.abs(newTargetX - gameState.charPositionX);
        const walkSpeed = 50;
        const walkDuration = Math.max(1000, (distance / walkSpeed) * 1000);
        
        gameState.transitionDuration = `${walkDuration / 1000}s`;
        gameState.charPositionX = newTargetX;
        gameState.isWalking = true;
        render();
        
        gameIntervals.movement = setTimeout(() => {
            gameState.isWalking = false;
            render();
            gameIntervals.movement = setTimeout(movementTick, Math.random() * 3000 + 2000);
        }, walkDuration);
    } else {
        gameState.isWalking = false;
        render();
        gameIntervals.movement = setTimeout(movementTick, Math.random() * 3000 + 2000);
    }
}

function stopGame() {
    Object.values(gameIntervals).forEach(id => {
        if (id) {
            clearInterval(id);
            clearTimeout(id);
        }
    });
    gameIntervals = { clock: null, decay: null, movement: null, death: null, save: null };
}

function init() {
    stopGame();
    dialogueDatabase = buildFullDatabase();
    const savedState = loadState();
    gameState = (savedState && savedState.isAlive) ? savedState : createNewGame();
    
    // Hide overlays on start/restart
    dom.overlays.cutscene.classList.add('hidden');
    dom.overlays.gameOver.classList.add('hidden');

    gameIntervals.clock = setInterval(clockTick, 1000);
    gameIntervals.decay = setInterval(decayTick, DECAY_TICK_INTERVAL);
    gameIntervals.death = setInterval(deathCheck, 1000);
    movementTick(); // Start the first movement tick

    // Save game state periodically
    gameIntervals.save = setInterval(saveState, 5000);
    
    render();
}

// Attach listeners once
dom.ui.actionsContainer.addEventListener('click', handleActionClick);
dom.overlays.restartBtn.addEventListener('click', init);
document.body.addEventListener('change', e => {
    if (e.target.id === 'image-upload') handleImageUpload(e);
});

// Start the game
init();

});
</script>
<script type="module" src="/index.tsx"></script>
</body>
</html>